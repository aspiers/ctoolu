#! /usr/bin/env ruby
require 'rubygems'
require 'dbus'
require 'gtk2'
require 'yaml'

HOME = ENV['HOME']

# actual url is constructed as url % pattern.match(text).captures
CtooluAction = Struct.new :label, :pattern, :url, :commands

class CtooluCommand < Struct.new :label, :command, :keep_output
  def execute(captures)
    # TODO honor keep_output
    substituted = command % captures
    if keep_output
      $clipboard.Set `#{substituted}`
    else
      run_in_background substituted
    end
  end

  private
  def run_in_background(command)
    child_pid = fork
    if child_pid
      # reap and ignore the return status, don't leave a zombie around
      Process.detach(child_pid)
    else
      exec command
    end
  end
end

# returns an Array of CtooluAction
def load_rule_file(file_name)
  YAML.load_file file_name
end

# returns an Array of all CtooluActions.
# FIXME: no precedence or overriding is implemented
def load_actions
  try_dirs = [
              "./rules",
              "#{HOME}/.local/share/ctoolu",
              "/usr/share/ctoolu",
             ]

  actions = try_dirs.map do |dir|
    file_names = Dir.glob(File.join(dir, "*.yaml"))
    file_names.map { |fn| load_rule_file(fn) }
  end
  # Now actions is a nested Array of CtooluAction,
  # grouped by file and directory. Flatten the 2 groupings.
  actions.flatten!(2)

  if actions.empty?
    fail "No rules found in #{try_configs.join ','}"
  end
  actions
end

$actions = load_actions

def clipboard_changed(text)
  # how to deal with multiple matches? warn but do only one
  $actions.each do |action|
    match_data = action.pattern.match(text)
    if match_data
      match_menu action, match_data.captures
    end
  end
end

def url_copy(url)
  $clipboard.Set url
end

# http://ruby-gnome2.sourceforge.jp/hiki.cgi?Gtk%3A%3AMenu
def match_menu(action, captures)
  menu = Gtk::Menu.new

  label_item = Gtk::MenuItem.new(action.label)
  label_item.signal_connect("activate") do
    action.url ||= "%s"
    url_copy(action.url % captures)
  end
  menu.append label_item

  menu.append Gtk::MenuItem.new(nil) # separator

  action.commands ||= []
  action.commands.each do |command|
    item = Gtk::MenuItem.new(command.label)
    item.signal_connect("activate") do
      command.execute captures
    end
    menu.append item
  end

  menu.append Gtk::MenuItem.new(nil) # separator
  menu.append Gtk::MenuItem.new("_Cancel") # do nothing

  menu.show_all

  parent_shell = parent_item = nil
  mouse_button = 1
  activation_time = 0           # Time.now.to_i did not work
  menu.popup(parent_shell, parent_item, mouse_button, activation_time)
end

bus = DBus::SessionBus.instance

clipboard_relay_svc = bus["net.vidner.ClipboardRelay"]
clipboard = clipboard_relay_svc.object "/net/vidner/ClipboardRelay/Clipboard"
clipboard.introspect
# FIXME there is no ProxyObject#interfacce
# FIXME ProxyObjectInterface#on_signal does not mimic ProxyObject#on_signal
clipboard.default_iface = "net.vidner.ClipboardRelay"
clipboard.on_signal("Changed") { |text| clipboard_changed(text) }
$clipboard = clipboard

bus.glibize
Gtk.main
